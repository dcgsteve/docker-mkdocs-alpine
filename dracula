#!/usr/bin/perl
#
# All around crazy stuff...
#

use strict;
use warnings;
use Path::Tiny;
use JSON::MaybeXS;
use MIME::Types;

my ($wiki) = map { path($_) } @ARGV;
die "Usage: dracula <path_to_wiki>\n" unless $wiki and $wiki->is_dir;

my $docs = $wiki->child('docs');
my $mdb  = MIME::Types->new;
my %db;

my $i = $docs->iterator({ recurse => 1 });
while (my $f = $i->()) {
  next unless $f->is_file;

  my $meta = extract_meta($f);

  push @{ $db{files} }, $f->relative($docs);
  next unless $meta;

  push @{ $db{need_rewrite} }, $f if $meta->{rewrite};
  for my $obj (@{ $meta->{objs} }) {
    my $type = $obj->{type};
    my $id   = $obj->{id};

    if (my $prev = $db{objs}{$type}{$id}) {
      die "FATAL: object $type/$id found in $f was previously declared in $prev->{file}\n";
    }

    $db{objs}{$type}{$id} = {
      file => $f,
      type => $type,
      id   => $id,
      obj  => $obj,
    };
  }
}

for my $f (@{ $db{need_rewrite} }) {
  rewrite_file($f, \%db);
}

$wiki->child('db.json')->spew_raw(JSON::MaybeXS->new->convert_blessed->encode(\%db));


###

sub extract_meta {
  my ($f, $db) = @_;
}


### Build phase
sub rewrite_file {
  my ($f, $db) = @_;
}


####

sub _log {
  return unless $ENV{DEBUG};
  if (ref $_[0]) { print "\n"; shift }
  print "@_\n";
}

sub debug { _log(@_) }
sub trace { _log('    . ', @_) }
