#!/usr/bin/perl
#
# All around crazy stuff...
#

use strict;
use warnings;
use Path::Tiny;
use JSON::MaybeXS;
use MIME::Types;
use Getopt::Long;
use Data::Dumper;


#######################################
### Good old usage...

sub usage {
  my $ec = 1;
  $ec = ${ shift() } if ref($_[0]) eq 'SCALAR';

  print <<EOU;
Usage: dracula <path_to_wiki> [<build_path>]

  The <path_to_wiki> must be a directory with a docs/
  subdirectory where the files are stored.

  If <build_path> is present, it will be created, with
  a db.json file at the root. A docs/ subfolder will
  contain the duplicate of the <path_to_wiki> with
  all the magic applied.


Options:

  --help,-?   this message
  --debug     enable extensive debug information

EOU

  print "FATAL: @_\n" if @_;
  exit($ec);
}


#######################################
### Parse those options, validate those parameters

my %opts;
GetOptions(\%opts, 'help|?', 'debug') or usage();
usage(\0) if $opts{help};
$ENV{DEBUG} = 1 if $opts{debug};

my ($wiki, $output_path) = map { path($_) } @ARGV;
usage('requires a source directory') unless $wiki and $wiki->is_dir;


#######################################
### We are good to go...

# Make this a gloabal, for performance/caching reasons
our $mdb = MIME::Types->new;

# Do our dance...
my $db = parse_wiki($wiki);

my $ns = $db->{notices} ||= [];
if (@$ns) {
  print "\nNotices detected:\n";
  print " . " . uc($_->[0]) . ": $_->[2]\n" for @$ns;
}

build_wiki($output_path, $db);
exit(0);


#######################################
### Build phases - parsing

sub parse_wiki {
  my ($wiki) = @_;

  my $docs = $wiki->child('docs');
  my %db = (root => $wiki, docroot => $wiki->child('docs'));

  my $i = $docs->iterator({ recurse => 1 });
  while (my $f = $i->()) {
    next unless $f->is_file;

    ## extract metadata from file
    my $meta = extract_meta($f, \%db);

    ## Keep track of all files we find, with their ID's, we have multiple files
    my $rf = $f->relative($docs);
    push @{ $db{files}{all} }, $rf;

    if    ($meta->{skip})    { push @{ $db{files}{skipped} }, $rf }
    elsif ($meta->{rewrite}) { push @{ $db{files}{rewrite} }, $rf }
    else                     { push @{ $db{files}{copy} },    $rf }

    ## Add all found objects to our DB
    for my $obj (@{ $meta->{objs} || [] }) {
      my $uid = $obj->{uid};

      if (my $prev = $db{objs}{$uid}) {
        push @{ $db{notices} },
          [error => $f, "object '$uid' found in $f was previously declared at $prev->{file}, line $prev->{line}"];
        next;
      }

      $db{objs}{$uid} = $obj;
    }
  }

  return \%db;
}


#######################################
### Build phase

sub build_wiki {
  my ($output_path, $db) = @_;
  return unless $output_path;

  ## Don't generate nothing if we have errors, warnings are ok
  die "FATAL: skipping wiki building, errors detected\n" if grep { $_->[0] eq 'error' } @{ $db->{notices} };

  debug(\"", "Build output wiki");

  my $docroot  = $output_path->child('docs');
  my $src_dest = sub {
    my $src  = $db->{docroot}->child($_[0]);
    my $dest = $docroot->child($_[0]);
    $dest->parent->mkpath;
    return ($src, $dest);
  };

  for my $f (@{ $db->{files}{rewrite} || [] }) {
    my ($src, $dest) = $src_dest->($f);
    trace("rewrite '$src' to '$dest'");
    rewrite_file($f, $db, $src, $dest);
  }

  for my $f (@{ $db->{files}{copy} || [] }) {
    my ($src, $dest) = $src_dest->($f);
    trace("copy '$src' to '$dest'");
    $src->copy($dest);
  }

  $output_path->child('db.json')->spew_raw(JSON::MaybeXS->new->convert_blessed->canonical->encode($db));
}


#######################################
### Extract metadata from files

sub extract_meta {
  my ($f, $db) = @_;

  debug(\"", "Check file $f");

  my $docs = $db->{docroot};

  my $mime  = $mdb->mimeTypeOf($f->basename);
  my $g_obj = {
    type      => 'file',
    id        => $f->relative($docs),
    parent    => $f->parent->relative($docs),
    name      => $f->basename,
    mime_type => "$mime",
  };
  $g_obj->{uid} = "$g_obj->{type}.$g_obj->{id}";
  my %meta = (objs => [$g_obj]);

  parse_dsl($f, $db, \%meta) if $mime and $mime eq 'text/markdown';

  return \%meta;
}


#######################################
### Our super DSL parser

sub parse_dsl {
  my ($f, $db, $meta) = @_;

  ## All files through here will need rewrite
  $meta->{rewrite} = 1;

  ## This is our stack-based parser
  my $objs  = $meta->{objs};
  my $g_obj = $objs->[0];
  my @stack = ({ ctx => 'global', c => $g_obj }, { ctx => 'obj', c => $g_obj, end_on_empty_line => 1 });
  $meta->{seq} = \my @seq;

  ## Prepare for line-by-line parsing
  my @lines = $f->lines({ chomp => 1 });
  push @lines, \'';    ## EOF marker

  ## Start the parse...
  my $line = 0;
  while (defined(my $l = shift @lines)) {

    ## EOF handling - we allow one last loop to detect
    my $eof = ref($l) ? 1 : 0;

    ## Keep track of the top of the stack, easier access
    $line++;
    my $sp    = $stack[-1];
    my $ctx   = $sp->{ctx};
    my $c_obj = $sp->{c};
    debug(
      sprintf(
        '%4d %s/%s/%s: %s',
        $line, $ctx, $c_obj->{type},
        (exists $c_obj->{id} ? $c_obj->{id} : '<no id>'),
        ($eof                ? '<<EOF>>'    : $l)
      )
    );

    ## Helpers...
    my $keep_line = sub { push @{ $c_obj->{buf} }, [$line, $l] };
    my $keep_seq = sub { push @seq, delete $c_obj->{buf} if exists $c_obj->{buf} };

    ## Manage here-documents
    if ($ctx eq 'here_doc') {
      if ($eof) {
        push @{ $db->{notices} }, [error => $f, "file $f ended inside a here-doc (looking for $sp->{terminator})"];
        pop @stack;
        $line-- && redo;
      }

      if ($l =~ m/^\s*\Q$sp->{terminator}\E$/) {
        trace('found terminator');
        $c_obj->{attrs}{ $sp->{field} } = $sp->{buf};
        pop @stack;
      }
      else {
        trace('just another heredoc line');
        $sp->{buf} .= "$l\n";
      }
      next;
    }

    ## When inside a object, we only accept attrs and empty lines
    ## we drop from this ctx on the first non-matching line
    if ($ctx eq 'obj') {
      if ($eof) {
        trace('EOF, pushing last obj and empty lines, redoing');
        push @seq, pop @stack;
        $keep_seq->();    ## keep trailing WS if we have it
        $line-- and redo; ## we need to keep the line count straight
      }

      ## explicit .end...
      elsif ($l =~ m/^\s*\.end(:?\s+.+)$/) {
        trace('explicit end of object');
        push @seq, pop @stack;
        $keep_seq->();    ## keep trailing WS if we have it
      }

      ## no nested objects!
      elsif ($l =~ m/^\s*\.def\s+/) {
        trace('another object detected, ending current one and redoing parser');
        push @seq, pop @stack;
        $keep_seq->();    ## keep trailing WS if we have it
        $line-- and redo; ## we need to keep the line count straight
      }

      ## empty lines
      elsif ($l =~ m/^\s*$/) {
        if ($sp->{end_on_empty_line}) {
          trace('end on empty line triggered, ending obj and redoing parse');
          push @seq, pop @stack;
          $line-- and redo;    ## we need to keep the line count straight
        }
        else {
          trace('keep the empty line');
          $keep_line->();
        }
      }

      ## named here-doc
      elsif ($l =~ m/^\s*\.(\w+)\s+<<(\S*?)\s*$/) {
        push @stack,
          {
          ctx        => 'here_doc',
          c          => $c_obj,
          field      => $1,
          terminator => $2 || '.end',
          line       => $line,
          };
        trace("Starting heredoc for field $stack[-1]{field} (terminator $stack[-1]{terminator})");
      }

      ## straight attr => value
      elsif ($l =~ m/^\s*\.(\w+)\s+(.+?)\s*$/) {
        $c_obj->{attrs}{ lc($1) } = $2;
        delete $c_obj->{buf};    ## Drop empty lines between attrs
        trace("found value '$2' for attr '$1'");
      }

      ## nothing more to parse here
      else {
        trace('unparsed object line, ending && redoing parse');
        push @seq, pop @stack;
        $keep_seq->();           ## keep trailing WS if we have it
        $line-- and redo;        ## we need to keep the line count straight
      }

      next;
    }

    ## This is the global ctx, we keep lines and look out for objects and actions
    if ($ctx eq 'global') {
      if ($eof) {
        trace('file ends...');
        $keep_seq->();
      }

      # the last .title always wins. If we don't have one, the first h1 header wins
      elsif ($l =~ m/^.title\s+(.+)$/) {
        $g_obj->{title} = $1;
        trace("Set title to '$g_obj->{title}'");
      }
      elsif ($l =~ m/^#\s+(.+?)(:?\s+#)$/) {    ## first-level markdown header
        $meta->{title} ||= $1;
        $keep_line->();
        trace("Found H1, title is now '$g_obj->{title}'");
      }

      ## A new object is defined
      elsif ($l =~ m/^\.def\s+(\w+)\s+(.+?)\s*$/) {
        push @$objs, my $c = { uid => "$1.$2", type => $1, id => $2, line => $line, file => $g_obj->{id}, attrs => {} };
        push @stack, { ctx => 'obj', c => $c, line => $line };
        $keep_seq->();
        trace("new object detected $c->{uid}");
      }

      ## Index action
      elsif ($l =~ m/^\.index$/) {
        $keep_seq->();
        push @stack, {
          ctx               => 'obj',
          end_on_empty_line => 1,       ## first empty line ends the object...
          line              => $line,
          c                 => {
            uid         => "action.$g_obj->{uid}.$line",
            type        => 'action',
            action      => 'select',
            target_type => 'files',
            where       => { path => $f->parent->relative($db->{docroot}) },
            order_by    => 'basename',
            skip        => [$g_obj->{id}],
            file        => $g_obj->{id},
            line        => $line,
          }
        };
        trace('new index action');
      }

      ## Unparsed command
      elsif ($l =~ m/^\./) {
        push @{ $db->{notices} }, [warn => $f, "unparsed command at $f, line $line: $l"];
        $keep_line->();
      }

      ## Fallback, just keep track of things
      else {
        trace('keep line as is');
        $keep_line->();
      }

      next;
    }
  }

  my $struct = _get_structure_from_seq(\@seq, $f, $db);
  $g_obj->{structures} = $struct;

  return;
}

sub _get_structure_from_seq {
  my ($seq, $f, $db) = @_;

  ### cleanup @seq, create the document final structure
  my @struct;
  for my $e (@$seq) {
    ## Text blocks, pass them through
    if (ref($e) eq 'ARRAY') {
      if (@struct and ref($struct[-1]) eq 'ARRAY') {    ## merge multiple sets of lines
        push @{ $struct[-1] }, @$e;
      }
      else {
        push @struct, $e;
      }
    }

    ## We have a Stack context
    elsif (exists $e->{ctx} and $e->{ctx}) {            ## a stack ctx, need to dig deeper
      if ($e->{ctx} eq 'obj') {                         ## ok, some objects are important for the structure...
        my $type = $e->{c}{type};
        if ($type eq 'action') {                        ## we keep these intact
          push @struct, $e->{c};
        }
        elsif ($type ne 'file') {                       ## other non-file objects are important for the structure
          push @struct, {                               ## Keep the reference to the object, avoids recursion later on
            uid  => $e->{c}{uid},
            type => $type,
            id   => $e->{c}{id},
          };
        }
      }
      else {
        push @{ $db->{notices} },
          [error => $f, "could not interpret a stack ctx of type '$e->{ctx}' at $f, line $e->{ctx}{line}"];
      }
    }
    else {
      push @{ $db->{notices} },
        [error => $f, "could not interpret a sequence element " . Dumper($e) . " at $f, line $e->{ctx}{line}"];
    }
  }

  return \@struct;
}


#######################################
### Rewrite files that need rewritting
sub rewrite_file {
  my ($f, $db) = @_;
}


####

sub _log {
  return unless $ENV{DEBUG};
  if (ref $_[0]) { print "\n"; shift }
  print "@_\n";
}

sub debug { _log(@_) }
sub trace { _log('    . ', @_) }
