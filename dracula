#!/usr/bin/perl
#
# All around crazy stuff...
#

use strict;
use warnings;
use Path::Tiny;
use JSON::MaybeXS;
use MIME::Types;
use Getopt::Long;
use Data::Dumper;


#######################################
### Good old usage...

sub usage {
  my $ec = 1;
  $ec = ${ shift() } if ref($_[0]) eq 'SCALAR';

  print <<EOU;
Usage: dracula <path_to_wiki> [<build_path>]

  The <path_to_wiki> must be a directory with a docs/
  subdirectory where the files are stored.

  If <build_path> is present, it will be created, with
  a db.json file at the root. A docs/ subfolder will
  contain the duplicate of the <path_to_wiki> with
  all the magic applied.


Options:

  --help,-?   this message
  --debug     enable extensive debug information

EOU

  print "FATAL: @_\n" if @_;
  exit($ec);
}


#######################################
### Parse those options, validate those parameters

my %opts;
GetOptions(\%opts, 'help|?', 'debug') or usage();
usage(\0) if $opts{help};
$ENV{DEBUG} = 1 if $opts{debug};

my ($wiki, $output_path) = map { path($_) } @ARGV;
usage('requires a source directory') unless $wiki and $wiki->is_dir;


#######################################
### We are good to go...

# Make this a gloabal, for performance/caching reasons
our $mdb = MIME::Types->new;

# Do our dance...
my $db = parse_wiki($wiki);

my $ns = $db->{notices} ||= [];
if (@$ns) {
  print "\nNotices detected:\n";
  print " . " . uc($_->[0]) . ": $_->[2]\n" for @$ns;
}

build_wiki($output_path, $db);
exit(0);


#######################################
### Build phases - parsing

sub parse_wiki {
  my ($wiki) = @_;

  my $docs = $wiki->child('docs');
  my %db = (root => $wiki, docroot => $wiki->child('docs'));

  my $i = $docs->iterator({ recurse => 1 });
  while (my $f = $i->()) {
    next unless $f->is_file;

    ## extract metadata from file
    my $meta = extract_meta($f, \%db);

    ## Keep track of all files we find, with their ID's, we have multiple files
    my $rf = $f->relative($docs);
    push @{ $db{files}{all} }, $rf;

    if    ($meta->{skip})    { push @{ $db{files}{skipped} }, $rf }
    elsif ($meta->{rewrite}) { push @{ $db{files}{rewrite} }, $rf }
    else                     { push @{ $db{files}{copy} },    $rf }

    ## Add all found objects to our DB
    for my $obj (@{ $meta->{objs} || [] }) {
      my $uid = $obj->{uid};

      if (my $prev = $db{objs}{$uid}) {
        push @{ $db{notices} },
          [error => $f, "object '$uid' found in $f was previously declared at $prev->{file}, line $prev->{line}"];
        next;
      }

      $db{objs}{$uid} = $obj;
    }
  }

  return \%db;
}


#######################################
### Build phase

sub build_wiki {
  my ($output_path, $db) = @_;
  return unless $output_path;

  ## Don't generate nothing if we have errors, warnings are ok
  die "FATAL: skipping wiki building, errors detected\n" if grep { $_->[0] eq 'error' } @{ $db->{notices} };

  debug(\"", "Build output wiki");

  my $docroot  = $output_path->child('docs');
  my $src_dest = sub {
    my $src  = $db->{docroot}->child($_[0]);
    my $dest = $docroot->child($_[0]);
    $dest->parent->mkpath;
    return ($src, $dest);
  };

  for my $f (@{ $db->{files}{rewrite} || [] }) {
    my ($src, $dest) = $src_dest->($f);
    trace("rewrite '$src' to '$dest'");
    rewrite_file($f, $db, $src, $dest);
  }

  for my $f (@{ $db->{files}{copy} || [] }) {
    my ($src, $dest) = $src_dest->($f);
    trace("copy '$src' to '$dest'");
    $src->copy($dest);
  }

  $output_path->child('db.json')->spew_raw(JSON::MaybeXS->new->convert_blessed->canonical->encode($db));
}


#######################################
### Extract metadata from files

sub extract_meta {
  my ($f, $db) = @_;

  debug(\"", "Check file $f");

  my $docs = $db->{docroot};

  my $mime  = $mdb->mimeTypeOf($f->basename);
  my $g_obj = {
    type      => 'file',
    id        => $f->relative($docs),
    parent    => $f->parent->relative($docs),
    name      => $f->basename,
    mime_type => "$mime",
    attr      => { name => $f->basename },
  };
  $g_obj->{uid} = "$g_obj->{type}.$g_obj->{id}";
  my %meta = (objs => [$g_obj]);

  parse_dsl($f, $db, \%meta) if $mime and $mime eq 'text/markdown';

  return \%meta;
}


#######################################
### Our super DSL parser

sub parse_dsl {
  my ($f, $db, $meta) = @_;

  ## All files through here will need rewrite
  $meta->{rewrite} = 1;

  ## This is our stack-based parser
  my $objs  = $meta->{objs};
  my $g_obj = $objs->[0];
  my @stack = ({ ctx => 'global', c => $g_obj }, { ctx => 'obj', c => $g_obj, end_on_empty_line => 1 });
  $meta->{seq} = \my @seq;

  ## Prepare for line-by-line parsing
  my @lines = $f->lines({ chomp => 1 });
  push @lines, \'';    ## EOF marker

  ## Start the parse...
  my $line = 0;
  while (defined(my $l = shift @lines)) {

    ## EOF handling - we allow one last loop to detect
    my $eof = ref($l) ? 1 : 0;

    ## Keep track of the top of the stack, easier access
    $line++;
    my $sp    = $stack[-1];
    my $ctx   = $sp->{ctx};
    my $c_obj = $sp->{c};
    debug(
      sprintf(
        '%4d %s/%s/%s: %s',
        $line, $ctx, $c_obj->{type},
        (exists $c_obj->{id} ? $c_obj->{id} : '<no id>'),
        ($eof                ? '<<EOF>>'    : $l)
      )
    );

    ## Helpers...
    my $keep_line = sub { push @{ $c_obj->{buf} }, [$line, $l] };
    my $keep_seq = sub { push @seq, delete $c_obj->{buf} if exists $c_obj->{buf} };

    ## Manage here-documents
    if ($ctx eq 'here_doc') {
      if ($eof) {
        push @{ $db->{notices} }, [error => $f, "file $f ended inside a here-doc (looking for $sp->{terminator})"];
        pop @stack;
        $line-- && redo;
      }

      if ($l =~ m/^\s*\Q$sp->{terminator}\E$/) {
        trace('found terminator');
        $c_obj->{attr}{ $sp->{field} } = $sp->{buf};
        pop @stack;
      }
      else {
        trace('just another heredoc line');
        $sp->{buf} .= "$l\n";
      }
      next;
    }

    ## When inside a object, we only accept attrs and empty lines
    ## we drop from this ctx on the first non-matching line
    if ($ctx eq 'obj') {
      if ($eof) {
        trace('EOF, pushing last obj and empty lines, redoing');
        push @seq, pop @stack;
        $keep_seq->();    ## keep trailing WS if we have it
        $line-- and redo; ## we need to keep the line count straight
      }

      ## explicit .end...
      elsif ($l =~ m/^\s*\.end(:?\s+.+)$/) {
        trace('explicit end of object');
        push @seq, pop @stack;
        $keep_seq->();    ## keep trailing WS if we have it
      }

      ## no nested objects!
      elsif ($l =~ m/^\s*\.def\s+/) {
        trace('another object detected, ending current one and redoing parser');
        push @seq, pop @stack;
        $keep_seq->();    ## keep trailing WS if we have it
        $line-- and redo; ## we need to keep the line count straight
      }

      ## empty lines
      elsif ($l =~ m/^\s*$/) {
        if ($sp->{end_on_empty_line}) {
          trace('end on empty line triggered, ending obj and redoing parse');
          push @seq, pop @stack;
          $line-- and redo;    ## we need to keep the line count straight
        }
        else {
          trace('keep the empty line');
          $keep_line->();
        }
      }

      ## named here-doc
      elsif ($l =~ m/^\s*\.(\w+)\s+<<(\S*?)\s*$/) {
        push @stack,
          {
          ctx        => 'here_doc',
          c          => $c_obj,
          field      => $1,
          terminator => $2 || '.end',
          line       => $line,
          };
        trace("Starting heredoc for field $stack[-1]{field} (terminator $stack[-1]{terminator})");
      }

      ## straight attr => value
      elsif ($l =~ m/^\s*\.(\w+)\s+(.+?)\s*$/) {
        $c_obj->{attr}{ lc($1) } = $2;
        delete $c_obj->{buf};    ## Drop empty lines between attrs
        trace("found value '$2' for attr '$1'");
      }

      ## nothing more to parse here
      else {
        trace('unparsed object line, ending && redoing parse');
        push @seq, pop @stack;
        $keep_seq->();           ## keep trailing WS if we have it
        $line-- and redo;        ## we need to keep the line count straight
      }

      next;
    }

    ## This is the global ctx, we keep lines and look out for objects and actions
    if ($ctx eq 'global') {
      if ($eof) {
        trace('file ends...');
        $keep_seq->();
      }

      # the first h1 header will serve as attr.title
      elsif ($l =~ m/^#\s*(.+?)(\s+#)?$/) {
        $g_obj->{attr}{title} ||= $1;
        $keep_line->();
        trace("Found H1, title is now '$g_obj->{attr}{title}'");
      }

      ## A new object is defined
      elsif ($l =~ m/^\.def\s+(\w+)\s+(.+?)\s*$/) {
        push @$objs,
          my $c = {
          uid  => "$1.$2",
          type => $1,
          id   => $2,
          line => $line,
          file => $g_obj->{id},
          attr => { name => $2 },
          };
        push @stack, { ctx => 'obj', c => $c, line => $line };
        $keep_seq->();
        trace("new object detected $c->{uid}");
      }

      ## Index action
      elsif ($l =~ m/^\.index$/) {
        $keep_seq->();
        push @stack, {
          ctx               => 'obj',
          end_on_empty_line => 1,       ## first empty line ends the object...
          line              => $line,
          c                 => {
            uid         => "action.index.$g_obj->{uid}.$line",
            type        => 'action',
            action      => 'index',
            target_type => 'files',
            where       => {
              parent    => $f->parent->relative($db->{docroot}),
              mime_type => 'text/x-markdown',
            },
            order_by => 'num attr.order=100',    ## Order by attr.order, if not found use 100
            skip     => [$g_obj->{uid}],
            file     => $g_obj->{id},
            line     => $line,
          }
        };
        trace('new index action');
      }

      ## Unparsed command
      elsif ($l =~ m/^\./) {
        push @{ $db->{notices} }, [warn => $f, "unparsed command at $f, line $line: $l"];
        $keep_line->();
      }

      ## Fallback, just keep track of things
      else {
        trace('keep line as is');
        $keep_line->();
      }

      next;
    }
  }

  my $struct = _get_structure_from_seq(\@seq, $f, $db);
  $g_obj->{structure} = $struct;

  return;
}

sub _get_structure_from_seq {
  my ($seq, $f, $db) = @_;

  ### cleanup @seq, create the document final structure
  my @struct;
  for my $e (@$seq) {
    ## Text blocks, pass them through
    if (ref($e) eq 'ARRAY') {
      if (@struct and ref($struct[-1]) eq 'ARRAY') {    ## merge multiple sets of lines
        push @{ $struct[-1] }, @$e;
      }
      else {
        push @struct, $e;
      }
    }

    ## We have a Stack context
    elsif (exists $e->{ctx} and $e->{ctx}) {            ## a stack ctx, need to dig deeper
      if ($e->{ctx} eq 'obj') {                         ## ok, some objects are important for the structure...
        my $type = $e->{c}{type};
        if ($type eq 'action') {                        ## we keep these intact
          push @struct, $e->{c};
        }
        elsif ($type ne 'file') {                       ## other non-file objects are important for the structure
          push @struct, {                               ## Keep the reference to the object, avoids recursion later on
            uid  => $e->{c}{uid},
            type => $type,
            id   => $e->{c}{id},
          };
        }
      }
      else {
        push @{ $db->{notices} },
          [error => $f, "could not interpret a stack ctx of type '$e->{ctx}' at $f, line $e->{ctx}{line}"];
      }
    }
    else {
      push @{ $db->{notices} },
        [error => $f, "could not interpret a sequence element " . Dumper($e) . " at $f, line $e->{ctx}{line}"];
    }
  }

  return \@struct;
}


#######################################
### Rewrite files that need rewritting

sub rewrite_file {
  my ($f, $db, $src, $dest) = @_;

  my $obj       = $db->{objs}{"file.$f"};
  my $structure = $obj->{structure};

  my $fh = $dest->openw_raw;
  for my $e (@$structure) {
    if (ref($e) eq 'ARRAY') {    ## Direct content - passthrough
      print $fh join("\n", (map { $_->[1] } @$e), "");
      next;
    }

    my $type = $e->{type};
    if (my $render = main->can("render_$type")) {    ## Easy object-type-specific renders :)
      $render->($fh, $e, $obj, $db);
    }
    else {
      trace("render not found for object $type");
    }
  }
  $fh->close;
}


#######################################
### Object renders

sub render_action {
  my ($fh, $obj, $g_obj, $db) = @_;

  my $action = $obj->{action};
  if (my $render = main->can("actions_render_$action")) {    ## Easy action-type-specific renders :)
    $render->(@_);
  }
  else {
    trace("render not found for action $action");
  }

}

## Helper to pick out a field value from an object
sub _field {
  my ($s, $spec, $default) = @_;

  if   ($spec =~ m/^attr\.(\w+)$/) { return ($s->{attr}{$1}, 1) if exists $s->{attr}{$1} }
  else                             { return ($s->{$spec},    1) if exists $s->{$spec} }

  return ($default, -1) if defined $default;

  return;
}

## build a order by structure.
# TODO: in a future version this should generate a anon sub that would sort the input list like this:
#
#  @sorted = $anon_sub->(@unsorted_objs);
#
# Some ideas:
#
#   if   ($args) { $field = "->{args}{'$field'}" }
#   else         { $field = "->{'$field'}" }
#
#   if ($def) {
#     $field .= "|| " . ($type eq 'alpha' ? "'$def'" : "$def");
#   }
#
#   my @vars = ('$a', '$b');
#   @vars = reverse @vars if $desc eq 'desc';
#
#   my $sub = 'sub { sort { ';
#   $sub .= "($vars[0]$field) " . ($type eq 'alpha' ? ' cmp ' : ' <=> ') . "($vars[1]$field)";
#   $sub .= ' } @_ }';
#
#   trace("order_by for '$oby' ==> $sub");
#   return eval $sub;
#
sub _build_order_by {
  my ($obj) = @_;
  my $oby = $obj->{order_by};
  return unless $oby;

  trace(" order by is '$oby'");

  my $type = 'alpha';
  if ($oby =~ s/^(alpha|num)\s+//) {
    $type = $1;
  }
  trace("after type '$type', order by is '$oby'");

  my $desc = 'asc';
  if ($oby =~ s/^(asc|desc)\s+//) {
    $desc = $1;
  }
  trace("after desc '$desc', order by is '$oby'");

  my ($field, undef, $def) = $oby =~ m/^([\w\.]+)(=(.+))?$/;
  die "FATAL: failed to parse order_by clause '$oby' at $obj->{file}, line $obj->{line}\n" unless $field;

  return ($field, $def, ($desc eq 'desc'), ($type eq 'num'));
}


#######################################
#### Template utils

sub _tmpl_render {
  my ($tmpl, $obj) = @_;

  $tmpl =~ s/
    \{\{   ## initial marker for expression
    (.+?)  ## capture everything inside
    \}\}   ## final marker for expression
  /
    _tmpl_repl($obj, $1)
  /gex;

  return $tmpl;
}

sub _tmpl_repl {
  my ($obj, $expression) = @_;

  trace("expression starts as '$expression'");
  my $default;
  if ($expression =~ m/^\s*(.+?)\s*\|\|\s*['"](.*?)['"]\s*$/) {
    $default    = $2;
    $expression = $1;
  }

  trace(" after defaults parsing, expression '$expression', default "
      . (defined($default) ? "'$default'" : '<no default>'));

  my ($val, $exists) = _field($obj, $expression, $default);
  trace(" field '$expression' for $obj->{uid}: val is " . ($exists ? "'$val'" : '<not found>'));

  if ($exists) {
    return $val if defined $val;
    return '<$expression undefined>';
  }

  return "<$expression not found>";
}


#######################################
#### Logger

sub _log {
  return unless $ENV{DEBUG};
  if (ref $_[0]) { print "\n"; shift }
  print "@_\n";
}

sub debug { _log(@_) }
sub trace { _log('    . ', @_) }
